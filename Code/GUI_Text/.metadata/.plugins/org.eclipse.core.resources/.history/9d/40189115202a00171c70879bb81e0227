package net.kerfuffle.Utilities.GUI.Text;

/*
* The MIT License (MIT)
*
* Copyright © 2014-2016, Heiko Brumme
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in all
* copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
* SOFTWARE.
*/

import java.awt.FontFormatException;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.FloatBuffer;
import java.nio.IntBuffer;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.lwjgl.BufferUtils;
import org.lwjgl.glfw.GLFW;
import org.lwjgl.opengl.GL;
import org.lwjgl.opengl.GL11;
import org.lwjgl.system.MemoryStack;
import org.lwjgl.system.MemoryUtil;
//import silvertiger.tutorial.lwjgl.core.Game;
//import silvertiger.tutorial.lwjgl.math.Matrix4f;
//import silvertiger.tutorial.lwjgl.text.Font;

import net.kerfuffle.Utilities.GUI.Color;
import net.kerfuffle.Utilities.GUI.Texture;

import static org.lwjgl.opengl.GL11.GL_BLEND;
import static org.lwjgl.opengl.GL11.GL_COLOR_BUFFER_BIT;
import static org.lwjgl.opengl.GL11.GL_DEPTH_BUFFER_BIT;
import static org.lwjgl.opengl.GL11.GL_FLOAT;
import static org.lwjgl.opengl.GL11.GL_ONE_MINUS_SRC_ALPHA;
import static org.lwjgl.opengl.GL11.GL_SRC_ALPHA;
import static org.lwjgl.opengl.GL11.GL_TRIANGLES;
import static org.lwjgl.opengl.GL11.glBlendFunc;
import static org.lwjgl.opengl.GL11.glClear;
import static org.lwjgl.opengl.GL11.glDrawArrays;
import static org.lwjgl.opengl.GL11.glEnable;
import static org.lwjgl.opengl.GL15.GL_ARRAY_BUFFER;
import static org.lwjgl.opengl.GL15.GL_DYNAMIC_DRAW;
import static org.lwjgl.opengl.GL20.GL_FRAGMENT_SHADER;
import static org.lwjgl.opengl.GL20.GL_VERTEX_SHADER;
import static org.lwjgl.opengl.GL20.glEnableVertexAttribArray;
import static org.lwjgl.opengl.GL20.glGetAttribLocation;
import static org.lwjgl.opengl.GL20.glVertexAttribPointer;
import static org.lwjgl.opengl.GL30.*;
import static org.lwjgl.opengl.GL15.*;

/**
* This class is performing the rendering process.
*
* @author Heiko Brumme
*/
public class Renderer {

   private VertexArrayObject vao;
   private VertexBufferObject vbo;
   private ShaderProgram program;

   private FloatBuffer vertices, color, texture;
   private int numVertices = 6;
   private final int vertex_size = 3;
   private boolean drawing;

   private Font font;
   private Font debugFont;

   /** Initializes the renderer. */
   public void init() {
       /* Setup shader programs */
       //setupShaderProgram();

       /* Enable blending */
       glEnable(GL_BLEND);
       glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

       /* Create fonts */
       try {
           font = new Font(new FileInputStream("res/Helvetica.ttf"), 16);
       } catch (FontFormatException | IOException ex) {
           Logger.getLogger(Renderer.class.getName()).log(Level.CONFIG, null, ex);
           font = new Font();
       }
       debugFont = new Font(12, false);
       
       
       vertices = BufferUtils.createFloatBuffer(numVertices * vertex_size);
       color = BufferUtils.createFloatBuffer(numVertices * vertex_size);
       texture = BufferUtils.createFloatBuffer(numVertices * vertex_size);
       //numVertices = 0;
       drawing = false;
   }

   /**
    * Clears the drawing area.
    */
   public void clear() {
       glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
   }

   /**
    * Begin rendering.
    */
   public void begin() {
       if (drawing) {
           throw new IllegalStateException("Renderer is already drawing!");
       }
       drawing = true;
       numVertices = 0;
   }

   /**
    * End rendering.
    */
   public void end() {
       if (!drawing) {
           throw new IllegalStateException("Renderer isn't drawing!");
       }
       drawing = false;
       flush();
   }

   /**
    * Flushes the data to the GPU to let it get rendered.
    */
   public void flush() {
       if (numVertices > 0) {
          // vertices.flip();
          
           int vbo_vertex_handle = glGenBuffers();
           glBindBuffer(GL_ARRAY_BUFFER, vbo_vertex_handle);
           glBufferData(GL_ARRAY_BUFFER, vertices, GL_STATIC_DRAW);
           glBindBuffer(GL_ARRAY_BUFFER, 0);
           
           int vbo_color_handle = glGenBuffers();
           glBindBuffer(GL_ARRAY_BUFFER, vbo_color_handle);
           glBufferData(GL_ARRAY_BUFFER, color, GL_STATIC_DRAW);
           glBindBuffer(GL_ARRAY_BUFFER, 0);
           
           int vbo_texture_handle = glGenBuffers();
           glBindBuffer(GL_ARRAY_BUFFER, vbo_texture_handle);
           glBufferData(GL_ARRAY_BUFFER, color, GL_STATIC_DRAW);
           glBindBuffer(GL_ARRAY_BUFFER, 0);

           
           glBindBuffer(GL_ARRAY_BUFFER, vbo_vertex_handle);
           GL11.glVertexPointer(vertex_size, GL11.GL_FLOAT, 0, 0l);

           glBindBuffer(GL_ARRAY_BUFFER, vbo_color_handle);
           GL11.glColorPointer(vertex_size, GL11.GL_FLOAT, 0, 0l);
           
           glBindBuffer(GL_ARRAY_BUFFER, vbo_texture_handle);
           GL11.glTexCoordPointer(vertex_size, GL11.GL_FLOAT, 0, 0l);
           

           GL11.glEnableClientState(GL11.GL_VERTEX_ARRAY);
           GL11.glEnableClientState(GL11.GL_COLOR_ARRAY);

           glDrawArrays(GL_TRIANGLES, 0, numVertices);

           GL11.glDisableClientState(GL11.GL_COLOR_ARRAY);
           GL11.glDisableClientState(GL11.GL_VERTEX_ARRAY);
           
           vertices.clear();
           color.clear();
           texture.clear();
           
       }
   }

   /**
    * Calculates total width of a text.
    *
    * @param text The text
    *
    * @return Total width of the text
    */
   public int getTextWidth(CharSequence text) {
       return font.getWidth(text);
   }

   /**
    * Calculates total height of a text.
    *
    * @param text The text
    *
    * @return Total width of the text
    */
   public int getTextHeight(CharSequence text) {
       return font.getHeight(text);
   }

   /**
    * Calculates total width of a debug text.
    *
    * @param text The text
    *
    * @return Total width of the text
    */
   public int getDebugTextWidth(CharSequence text) {
       return debugFont.getWidth(text);
   }

   /**
    * Calculates total height of a debug text.
    *
    * @param text The text
    *
    * @return Total width of the text
    */
   public int getDebugTextHeight(CharSequence text) {
       return debugFont.getHeight(text);
   }

   /**
    * Draw text at the specified position.
    *
    * @param text Text to draw
    * @param x    X coordinate of the text position
    * @param y    Y coordinate of the text position
    */
   public void drawText(CharSequence text, float x, float y) {
       font.drawText(this, text, x, y);
   }

   /**
    * Draw debug text at the specified position.
    *
    * @param text Text to draw
    * @param x    X coordinate of the text position
    * @param y    Y coordinate of the text position
    */
   public void drawDebugText(CharSequence text, float x, float y) {
       debugFont.drawText(this, text, x, y);
   }

   /**
    * Draw text at the specified position and color.
    *
    * @param text Text to draw
    * @param x    X coordinate of the text position
    * @param y    Y coordinate of the text position
    * @param c    Color to use
    */
   public void drawText(CharSequence text, float x, float y, Color c) {
       font.drawText(this, text, x, y, c);
   }

   /**
    * Draw debug text at the specified position and color.
    *
    * @param text Text to draw
    * @param x    X coordinate of the text position
    * @param y    Y coordinate of the text position
    * @param c    Color to use
    */
   public void drawDebugText(CharSequence text, float x, float y, Color c) {
       debugFont.drawText(this, text, x, y, c);
   }

   /**
    * Draws the currently bound texture on specified coordinates.
    *
    * @param texture Used for getting width and height of the texture
    * @param x       X position of the texture
    * @param y       Y position of the texture
    */
   public void drawTexture(Texture texture, float x, float y) {
       drawTexture(texture, x, y, Color.WHITE);
   }

   /**
    * Draws the currently bound texture on specified coordinates and with
    * specified color.
    *
    * @param texture Used for getting width and height of the texture
    * @param x       X position of the texture
    * @param y       Y position of the texture
    * @param c       The color to use
    */
   public void drawTexture(Texture texture, float x, float y, Color c) {
       /* Vertex positions */
       float x1 = x;
       float y1 = y;
       float x2 = x1 + texture.getWidth();
       float y2 = y1 + texture.getHeight();

       /* Texture coordinates */
       float s1 = 0f;
       float t1 = 0f;
       float s2 = 1f;
       float t2 = 1f;

       drawTextureRegion(x1, y1, x2, y2, s1, t1, s2, t2, c);
   }

   /**
    * Draws a texture region with the currently bound texture on specified
    * coordinates.
    *
    * @param texture   Used for getting width and height of the texture
    * @param x         X position of the texture
    * @param y         Y position of the texture
    * @param regX      X position of the texture region
    * @param regY      Y position of the texture region
    * @param regWidth  Width of the texture region
    * @param regHeight Height of the texture region
    */
   public void drawTextureRegion(Texture texture, float x, float y, float regX, float regY, float regWidth, float regHeight) {
       drawTextureRegion(texture, x, y, regX, regY, regWidth, regHeight, Color.WHITE);
   }

   /**
    * Draws a texture region with the currently bound texture on specified
    * coordinates.
    *
    * @param texture   Used for getting width and height of the texture
    * @param x         X position of the texture
    * @param y         Y position of the texture
    * @param regX      X position of the texture region
    * @param regY      Y position of the texture region
    * @param regWidth  Width of the texture region
    * @param regHeight Height of the texture region
    * @param c         The color to use
    */
   public void drawTextureRegion(Texture texture, float x, float y, float regX, float regY, float regWidth, float regHeight, Color c) {
       /* Vertex positions */
       float x1 = x;
       float y1 = y;
       float x2 = x + regWidth;
       float y2 = y + regHeight;

       /* Texture coordinates */
       float s1 = regX / texture.getWidth();
       float t1 = regY / texture.getHeight();
       float s2 = (regX + regWidth) / texture.getWidth();
       float t2 = (regY + regHeight) / texture.getHeight();

       drawTextureRegion(x1, y1, x2, y2, s1, t1, s2, t2, c);
   }

   /**
    * Draws a texture region with the currently bound texture on specified
    * coordinates.
    *
    * @param x1 Bottom left x position
    * @param y1 Bottom left y position
    * @param x2 Top right x position
    * @param y2 Top right y position
    * @param s1 Bottom left s coordinate
    * @param t1 Bottom left t coordinate
    * @param s2 Top right s coordinate
    * @param t2 Top right t coordinate
    */
   public void drawTextureRegion(float x1, float y1, float x2, float y2, float s1, float t1, float s2, float t2) {
       drawTextureRegion(x1, y1, x2, y2, s1, t1, s2, t2, Color.WHITE);
   }

   /**
    * Draws a texture region with the currently bound texture on specified
    * coordinates.
    *
    * @param x1 Bottom left x position
    * @param y1 Bottom left y position
    * @param x2 Top right x position
    * @param y2 Top right y position
    * @param s1 Bottom left s coordinate
    * @param t1 Bottom left t coordinate
    * @param s2 Top right s coordinate
    * @param t2 Top right t coordinate
    * @param c  The color to use
    */
   
   //TODO
   public void drawTextureRegion(float x1, float y1, float x2, float y2, float s1, float t1, float s2, float t2, Color c) {
//       if (vertices.remaining() < 7 * 6) {
//           /* We need more space in the buffer, so flush it */
//           flush();
//       }

       float r = c.getRed();
       float g = c.getGreen();
       float b = c.getBlue();

       vertices.put(new float[]{x1,y1, 0});
       vertices.put(new float[]{x1,y2, 0});
       vertices.put(new float[]{x2,y2, 0});
       
       vertices.put(new float[]{x1,y1, 0});
       vertices.put(new float[]{x2,y2, 0});
       vertices.put(new float[]{x2,y1, 0});
       vertices.flip();
       
       color.put(new float[]{r,g,b});
       color.put(new float[]{r,g,b});
       color.put(new float[]{r,g,b});
       
       color.put(new float[]{r,g,b});
       color.put(new float[]{r,g,b});
       color.put(new float[]{r,g,b});
       color.flip();
       
       
       texture.put(new float[]{s1,t1, 0});
       texture.put(new float[]{s1,t2, 0});
       texture.put(new float[]{s2,t2, 0});
       
       texture.put(new float[]{s1,t1, 0});	
       texture.put(new float[]{s2,t2, 0});
       texture.put(new float[]{s2,t1, 0});
       texture.flip();
       
       flush();
       
//       vertices.put(x1).put(y1).put(r).put(g).put(b).put(s1).put(t1);
//       vertices.put(x1).put(y2).put(r).put(g).put(b).put(s1).put(t2);
//       vertices.put(x2).put(y2).put(r).put(g).put(b).put(s2).put(t2);
//
//       vertices.put(x1).put(y1).put(r).put(g).put(b).put(s1).put(t1);
//       vertices.put(x2).put(y2).put(r).put(g).put(b).put(s2).put(t2);
//       vertices.put(x2).put(y1).put(r).put(g).put(b).put(s2).put(t1);
       
       //numVertices += 6;
   }


   /**
    * Dispose renderer and clean up its used data.
    */
   public void dispose() {
       MemoryUtil.memFree(vertices);

       if (vao != null) {
           vao.delete();
       }
       vbo.delete();
       program.delete();

       font.dispose();
       debugFont.dispose();
   }

   /** Setups the default shader program. */
   private void setupShaderProgram() {
       if (isDefaultContext()) {
           /* Generate Vertex Array Object */
           vao = new VertexArrayObject();
           vao.bind();
       } else {
           vao = null;
       }

       /* Generate Vertex Buffer Object */
       vbo = new VertexBufferObject();
       vbo.bind(GL_ARRAY_BUFFER);

       /* Create FloatBuffer */
       vertices = MemoryUtil.memAllocFloat(4096);

       /* Upload null data to allocate storage for the VBO */
       long size = vertices.capacity() * Float.BYTES;
       vbo.uploadData(GL_ARRAY_BUFFER, size, GL_DYNAMIC_DRAW);

       /* Initialize variables */
       numVertices = 0;
       drawing = false;

       /* Load shaders */
//       Shader vertexShader, fragmentShader;
//       if (isDefaultContext()) {
//           vertexShader = Shader.loadShader(GL_VERTEX_SHADER, "res/default.vert");
//           fragmentShader = Shader.loadShader(GL_FRAGMENT_SHADER, "res/default.frag");
//       } else {
//           vertexShader = Shader.loadShader(GL_VERTEX_SHADER, "res/legacy.vert");
//           fragmentShader = Shader.loadShader(GL_FRAGMENT_SHADER, "res/legacy.frag");
//       }
//
//       /* Create shader program */
//       program = new ShaderProgram();
//       program.attachShader(vertexShader);
//       program.attachShader(fragmentShader);
//       if (isDefaultContext()) {
//           program.bindFragmentDataLocation(0, "fragColor");
//       }
//       program.link();
//       program.use();
//
//       /* Delete linked shaders */
//       vertexShader.delete();
//       fragmentShader.delete();
//
//       /* Get width and height of framebuffer */
//       long window = GLFW.glfwGetCurrentContext();
//       int width, height;
//       try (MemoryStack stack = MemoryStack.stackPush()) {
//           IntBuffer widthBuffer = stack.mallocInt(1);
//           IntBuffer heightBuffer = stack.mallocInt(1);
//           GLFW.glfwGetFramebufferSize(window, widthBuffer, heightBuffer);
//           width = widthBuffer.get();
//           height = heightBuffer.get();
//       }
//
//       /* Specify Vertex Pointers */
//       specifyVertexAttributes();
//
//       /* Set texture uniform */
//       int uniTex = program.getUniformLocation("texImage");
//       program.setUniform(uniTex, 0);
//
//       /* Set model matrix to identity matrix */
//       Matrix4f model = new Matrix4f();
//       int uniModel = program.getUniformLocation("model");
//       program.setUniform(uniModel, model);
//
//       /* Set view matrix to identity matrix */
//       Matrix4f view = new Matrix4f();
//       int uniView = program.getUniformLocation("view");
//       program.setUniform(uniView, view);
//
//       /* Set projection matrix to an orthographic projection */
//       Matrix4f projection = Matrix4f.orthographic(0f, width, 0f, height, -1f, 1f);
//       int uniProjection = program.getUniformLocation("projection");
//       program.setUniform(uniProjection, projection);
   }

   /**
    * Specifies the vertex pointers.
    */
   private void specifyVertexAttributes() {
//       /* Specify Vertex Pointer */
//       //int posAttrib = program.getAttributeLocation("position");
//       program.enableVertexAttribute(posAttrib);
//       program.pointVertexAttribute(posAttrib, 2, 7 * Float.BYTES, 0);
//
//       /* Specify Color Pointer */
//       int colAttrib = program.getAttributeLocation("color");
//       program.enableVertexAttribute(colAttrib);
//       program.pointVertexAttribute(colAttrib, 3, 7 * Float.BYTES, 2 * Float.BYTES);
//
//       /* Specify Texture Pointer */
//       int texAttrib = program.getAttributeLocation("texcoord");
//       program.enableVertexAttribute(texAttrib);
//       program.pointVertexAttribute(texAttrib, 2, 7 * Float.BYTES, 5 * Float.BYTES);
//       
//       
//       
//       int posAttrib = glGetAttribLocation(id, "position");
//       glEnableVertexAttribArray(posAttrib);
//       glVertexAttribPointer(posAttrib, 2, GL_FLOAT, false, 7*Float.BYTES, 0);
   }

   
   public static boolean isDefaultContext() {
       return GL.getCapabilities().OpenGL32;
}
   
}